# 图上的算法



### 0x00 图的定义



**基本定义**

用$G=(V,E)$表示一张图，其中$V$表示图中的结点，$E$表示图上两结点的边。 如果对某条具体的边进行区分，可以分为无向图和有向图。 根据$V$和$E$之间关系，若$|E| << |V|^2$ ，则称$G$是一个稀疏图，若$|E| \sim |V|^2$，则称$G$是一个稠密图。



### 0x01 图的两种表示



- 邻接链表

  把图上的所有的结点$V$用一张链表$L$连起来，其中$L$上每个的节点$v$又是一张链表$L_v$的头，表示从$v$出发的边所对应的结点，即$v \to u$，则$u \in L_v$.

- 邻接矩阵

  初始化一个$|V| \times |V|$ 零矩阵$A=\mathbf{0}$，若存在$u \to v \in E$， 则标记$A_{uv} = 1$，显然我们可能用正整数标记图上不同的结点。

两种表示方式都可以很自然的表示无向图和有向图，特别地如果是无向图，那么对应的邻接矩阵是一个对称矩阵。 



**偏向使用**

- 邻接链表
  - 稀疏图
  - 若查找$u \to v$，需要遍历$L_u$。
  - 空间存储为$O(|V|+|E|)$，存储空间使用上可能小于邻接矩阵，但渐进上是一样的。
  - 鲁棒性高。
- 邻接矩阵
  - 稠密图
  - 查找某条边是否存在是极为方便的。
  - 空间存储度为$ O(|V|^2)$，在无向图下，由于是对称矩阵，所以只需要对角线和对角线上放的空间。
  - 每个记录项只需要1位空间。



### 0x02 广搜

广度优先搜索是图上一种遍历算法:

1. 选择以某个源节点$s$为开始，初始化一个队列$Q$，把$s$的子节点都扔到里面，

2. 再依次从$Q$里面取节点出来探索，

3. 若碰到第一次探索的节点，则将所有的子节点也加到队列$Q$里面。

4. 直到$Q$为空时。

   

```python
BFS(G, s):
    for each vertex u in G.V-{s}:  # 初始化
        u.color = WHITE
        u.d = infinity
        u.pi = NIL
    s.color = GRAY
    s.d = 0
    s.pi = NIL
    Q = {}
    ENQUEUE(Q, s)
    while Q is not empty:
        u = DEQUEUE(Q)
        for each v in G.Adj[u]:
            if v.color == WHITE:
                v.color = GRAY
                v.d = u.d + 1
                v.pi = u
                ENQUEUE(Q, v)
        u.color = BLACK
```





**关于Coloring的介绍** 已经探索过的结点标记为黑色，未被探索但是为黑丝的边界结点标记为灰色，其余的结点标记为白色。

**关于结点属性d**  用$v.d$表示从当且广搜树根结点$s$到$v$的路径长度。



**Definition** 对于给定$G=(V,E)$和源结点$s$在广搜下，定义$G$的前驱子图为$G_\pi = (V_\pi,E_\pi)$，其中$V_\pi = \{v \in : v.\pi \neq NIL\} \cup \{s\},E_\pi = \{(v.\pi, v): v \in V-\{s\}\}$.  若$G_\pi$上每一个结点$s$都可达，且只包含唯一的简单路径，而且是最短路径，则称$G_\pi$是一个==广度优先树==（广度优先生成树）.  $E_\pi$中的边称为树边。

**Lemma**  BFS会生成一个广度优先树。

**Definition** 在广搜的过程中，若在探索$u \to v$，其中$v$是白色结点，则在对应的广搜树中，称$u$是$v$的前驱或者父节点，记为$u = v.\pi$。 

**Definition** 记$\var(s,u)$表示$G$ 上$s$到$u$之间的最短路径。

**Theorem** 以源结点$s$为根结点的广搜树上的结点$v$，都是$G$上可以由$s$可达的，且树上$s \leadsto v$是$G$上$s$到$v$的==最短路径==. 特别地若$u$是$v$的直接前驱，则

$\var(s,v) = \var(s,u)+1$。

**Lemma** 给定$G=(V,E)$，设$s \in V$，则对任意边$(u,v) \in E$，有$\var(s,v) \leq \var(s,u) + 1$。 

这是一个有趣的bounder，无所谓$s$与$u,v$是否可达。

**Lemma** 对广搜树上任意的结点$v$，都有$\var(s,v) \leq v.d$.   

只要证明这个上界等号是成立的，则可以说明广搜得到的确实是最短路径。 

**Lemma** 在广搜的过程中任意深刻队列$Q$中最多只包含两个不同的$d$值，即考虑$Q=\{v_1,\cdots,v_r\}$，则有$v_r.d \leq v_1.d+1$，同时有

$v_i \leq v_{i+1}, i = 1,\cdots,r_1$.   换句话说$v_i.d$不降，且也不大于最后一个结点$v_1.d+1$，这是更为强的一个结论。

这是刻画广搜总是从边界水平向外推进的最根本的的原因， 需要考虑$Q$在入列和出列时操作。 

**Lemma** 在广搜的过程中若$v_i$比$v_j$先入列，且它们在某一时刻都在队列$Q$里面，则$v_i.d \leq v_j.d$ 。







### 0x03 深搜

深度优先搜索的步骤：

1. 选择以某个源结点$s$，选择它最近的出发边进行探索，
2. 对每一个的结点（无论是新的或者探索过的），都会选择它最近的出发边，且该出发边对应的端点没有被探索过进行探索。（DFS-VISIT）
3. 若新发现的结点没有出发边，则回到它在搜索过称的前驱结点进行继续探索。
4. 若$s$的出发边都被探索完毕，则在$G$上选择一个没有被探索过的结点继续探索。 （DFS）



````python
DFS(G):
    for each vertex u in G.V:  # 初始化
        u.color = WHITE
        u.pi = NIL
    time = 0
    for each vertex u in G.V:
        if u.color == WHITE:
            DFS-VISIT(G, u)  # 以u为源结点进行深度优先探索
            
DFS-VISIT(G, u):
    time = time + 1
    u.d = time
    u.color = GRAY            # 发现
    for each v in G.Adj[u]:   # 探索u的邻接结点
        if v.color == WHITE:  # 若发现新的未探索结点
            v.pi = u
            DFS-VISIT(G, v)   # 优先递归探索新的结点v
            # 探索完v后，循环继续进行，探索u的下一个邻接结点
    u.color = BLACK
    time = time + 1
    u.f = time                # 探索完成            
````



**关于时间区间** 将$v$第一次被发现的时间记为$v.d$，完成对$v$所有出发边并回到$v$时的时间记为$v.f$. 

**关于Coloring的介绍** 已经探索完成的的结点标记为黑色，出发边还没有探索完毕的结点标记为灰色，其余的结点标记为白色。



**Theorem** $G=(V,E)$在深搜下， 对于任意$u,v \in V$, 仅满足下述三种关系中的一种

1. 若$[u.d,u.f] \subset [v.d,v.f]$ ，则$u,v$在同一棵深度优先树中，且$u$是$v$的子孙结点;
2. 若$[v.d,v.f] \subset [u.d,u.f]$ ，则$u,v$在同一棵深度优先树中，且$v$是$u$的子孙结点;
3.  若$[v.d,v.f]$和$ [u.d,u.f]$ 完全分离，则$u,v$不在同一颗深度优先树中。



**Definition** 当DFS-VISIT生成以$u$为根结点的树称为深度优先树，即$T_u = (V_u, E_u)$，其中$V_u = \{v \in V: u.d < v.d < v.f < u.f \} \cup \{u\}, ~ E_u = \{(v.\pi,v): v \in {V_u}-{u}\}$.   

**Definition** 在深搜下，$G$的前驱子图定义为$G_\pi = (V,E_\pi)$，其中$E_\pi = \{(v.\pi,v): v.\pi \neq NIL\}$.   $G_\pi$是由多个深度优先树构成的深度优先森林。

**Definition** 对$G$进行深搜，根据生成的深度优先森林$G_\pi$，我们定义4种类的边：

1. **树边**（tree edge）  若$(u,v) \in E_\pi$，即在深搜的过程结点$v$是因为对边$(u,v)$的探索而首先被发现的，则$(u,v)$是树边。
2. **后向边** （back edge）若$(u,v) \in E$，且$v$是$u$在深搜树上的祖先结点。
3. **前向边** （forward edge）若$(u,v) \in E$，且$v$是$u$在深搜树上的子孙结点。
4. **横向边** （cross edge）不满足上述三种边的所有边， 即两个不同深搜树的边和同一个深搜树两个互不为子孙结点的边（没什么特殊关系的两点的边）。

**Proposition**  在深搜过程中，探索$(u,v)$时，$v$的颜色可以给定一些关于$(u,v)$的信息

1. 若$v$是白色，则$(u,v)$是一条树边;
2. 若$v$是灰色，则$(u,v)$是一条后向边;
3. 若$v$是黑色，则$(u,v)$可能是一条前向边或者横向边。



**Theorem** 对无向图进行深搜的过程中，不会出现前向边和横向边。



### 0x04 拓扑序

对于一个有向无环图$G$，其==拓扑排序==是$G$中所有结点的一种线性次序，该次序满足: 若$(u,v) \in G$，则$u$在拓扑序中应处于$u$的前面，因为可以想象如果$G$有环，是不可能排出一个拓扑序的。 



进行拓扑排序的步骤：

1. 对$G$先进行深搜，计算出所有结点的完成时间$v.f$，
2. 将所有结点按照$v.f$从大到小的顺序依次排列，得到的就是拓扑序。




**Lemma** 一个有向图$G$无环当且仅当对其深搜时不产生后向边。





### 0x05 强连通分量

有向图$G=(V,E)$的一个==强连通分量==一个最大结点集合$C \subseteq V$，对应任意的$u,v \in C$，路径$u \leadsto v$和$v \leadsto u$，即$C$中任意两个结点都是相互可达的。



**Definition** 用$G^T=(V,E^T)$表示$G=(V,E)$的转置图，即若$(u,v) \in E$，则$(v,e) \in E^T$.

**Lemma** 图$G^T$和$G$的强连通分量相同。



寻找强连通的步骤:

1. 对$G$进行一次深搜，计算出每个结点的完成时间$v.f$，
2. 对$G^T$在main loop中按照结点$v.f$递减的顺序再进行一次深搜，此时每个深搜树都是一个强连通分量。



**Definition** 有向图$G$的==分量图==示为$G^{SCC} = (V^{SCC},E^{SCC})$，设$G$的强连通分量为$C_1,\cdots,C_r$，将每个连通分量收缩为一个点记为$V^{SCC}=\{v_1,\cdots,v_2\}$.  若对于$x \in C_i, y \in C_j$，边$(x,y)$存在，则$(v_i,v_j) \in E^{SCC}$.  



**Lemma** 设$C,C'$为有向图$G$上的两个不同的强连通图，设$u,v \in C$和$u',v' \in C'$，若存在路径$u \leadsto u'$，则必不存在$v' \leadsto v$.

这是在说明分量图是一个有向的无环图。



**Definition** 将结点的发现实际和完成时间推广到结点的集合上:  $d(U)= \min\limits_{u \in U}\{u.d\},~ f(U)= \max\limits_{u \in U}\{u.d\}$.  下述在谈论这些时间是指的第一次深搜计算出来的时间。 

**Lemma**  设$C,C'$为有向图$G$上的两个不同的强连通图，设$u \in C$和$v \in C'$，若边$(u,v) \in E$存在，则$f(C) > f(C')$.   

这个结论想一下还是很显然的，因为$(u,v)$的存在，在深搜经过这条边的时候，在遍历完$C'$之前，$C$是不会遍历完的。

**Corollary** 设$C,C'$为有向图$G$上的两个不同的强连通图，设$u \in C$和$v \in C'$，若边$(u,v) \in E^T$存在，则$f(C') > f(C)$. 

这个推论的就有意义了，实际在$G^T$上深搜的时候，我们是先对完成时间最大的连通分量进行搜索，但是我要确保不会跑到其他的连通分量上去，显然这样的边在$G^T$不存在，因为$G^T$只存在从完成时间较小的连通分量到完成时间较大的边。



### 0x06 最小生成树



对于一个连通无向图$G(V,E)$，其每条的权重为$w(u,v)$.  $G$的==最小生成树==首先是$G$上的一个无环子图$T$，且$T$上边的权重之和$\sum\limits_{u,v \in T} w(u,v)$是最小的.



构造最小生成树的两种算法Kruskal算法和Prim算法都是基于贪心算法，它们共同的思想为

1. 管理一个边的集合$A$，$A$是某个最小生成树的子集;
2. 在某时刻往$A$里面增加边$(u,v)$的时候，$A\cup\{(u,v)\}$依然满足是某个最小生成树的子集;
3. 直到$A$为一个生成树为止. 

其中边$(u,v)$我们称为==安全边==.



**Definition** 无向图$G=(V,E)$的一个==切割==是对$V$的一个划分$(S,V-S)$.  若边$(u,v)$的一个端点位于$S$，另一个端点位于$V-S$，则称$(u,v)$==横跨==切割$(S,V-S)$.  

**Definition** 在所有横跨切割$(S,V-S)$的边中，权重最小的边称为==轻量级边==.  一般地，如果一条边是满足某个性质的所有边中权重最小的，则称该边是满足所给性质的一个==轻量级边==.

**Definition** 如果集合$A$中不存在横跨该切割的边，则称该切割==尊重==集合$A$. 



![image-20210911154236861](/home/maple/.config/Typora/typora-user-images/image-20210911154236861.png)



**Theorem** 若边集合$A$是某个做小生成树的子集，设切割$(S,V-S)$尊重$A$，那么横跨$(S,V-S)$权重最小的边$(u,v)$，对于集合$A$而言是安全的. 



**Corollary** 若边集合$A$是某个做小生成树的子集，设子图$G_A=(V,A)$中的一个连通分量为$C = (V_C,E_C)$. 若$(u,v)$是$G$上连接$C$和$G_A$中其他连通分量的一条轻量级边，则边$(u,v)$对于$A$是安全的. 

*proof*.  这是显然的，因为切割$(V_C,V-V_C)$是尊重$A$的，若不是尊重$A$的，那么存在一条$(u,v)$，$u \in V_C$和$v \in V-V_C$，这就和$C$是连通分量矛盾了.  



**Kruskal**算法

其算法的核心思想

1. 将$G$看做一个连接森林. 
2. 在初始阶段$G$的每个结点就是一棵树，此时连接任意两颗树的权重最小的边$(u,v)$，对$u$或者$v$而言是安全的.  因此可以将$(u,v)$加入到当前$A=\empty$中，使得$A=\empty \cup {(u,v)}$.  再将$u,v$合并称一棵树，此时$G$依然是一颗连接森林. 
3. 注意此时$G$上连接任意两棵树的边，都可以作为一个横跨尊重$A$的切割（因为$A$上边已经被收缩起来了），那么依然寻找$G$上连接两颗树的权重最小的边，因此对$A$而言这个边是安全的，然后再将这条边收缩起来. 
4. 余类推，直到$A$称为一个生成树. 

```python
minimum_spannning_tree_kruskal(G)
	A={};
    for each v in G.V
    	make_set(v)
    edges = sort_edges_into_nondecreasing_order(G) #权重最小的边都是可能是潜在的某个生成树的上边。
    for each (u,v) in edges
    	if find_set(v) != find_set(v) #不遍历A已经覆盖了得结点
        	take (u,v) in A
        	union(u,v)    
	return A
```



因此Kruskal算法中的集合$A$可能是森林，Kruskal算法所需的时间复杂度为$O(E\ln V)$. 



**Prim算法**

与Kruskal算法不同的是，Prim算法维护的集合$A$总是一颗树，这颗树的生成从任意结点开始，直到覆盖$G$的所有结点. 



其算法核心:

1.  任意选择$G$上的结点$u$，将连接$u$和其他结点权重最小的边$(u,v)$加入到$A=\empty \cup (u,v)$中.
2.  在$G$上寻找连接$A$与$A$之外的结点的所有边，找权重最小的边加入$A$中.
3.  余类推，直到$A$成为一颗最小生成树.



### 0x07 最短路径

在无向图上最短路径，就是边最少的简单路径.  

在带权有向图上最短路径，就是一条所有边权重加起来最小的简单路径.  



单源最短路径主要有涵盖下面三个问题

1.  单目的地最短路径问题 给定目的地$t$，求所有其他结点$v$到它的最短路径
2.  单结点对最短路径问题 给定两个结点$u,v$，求它们的最短路径
3.  所有结点对最短路径问题 求图上所有结点对$(u,v)$的最短路径



**Theorem** 最短路径的子路径也是最短路径



**关于有向图上的负权重的边**

负权重和正权重一样做加法就行，没有有什么区别.  只要不出现权重为负值的环路，就可以确保每个源结点可达的结点都有最短路径. 



**环路**

有两种环路:

1. 环路上的边权重加起来为负数的环路

   若给定源结点$s$可以到达该环路，那么从该环路可达的结点对$s$而言是没有最短路径的.  因为路径的权重可以无限的小，所以最短路径是不可能包含一个负值的环路的.

2. 环路上的边权重加起来为正数的环路

   一个最短路径上也是不可能包含一个环路的，因为只要从该路径上删除就可以得到一条权重更小的路径. 

3. 环路上的边权重加起来为0的环路

   一个最短路径上若有权重为0的环路，那么总可以删除它，得到一个权重与原来一样的最短路径，我们可以重复这个操作知道最短路径上没有权重为0的环路

综上可以找到最短路径中是没有环路的，即它是一条简单路径.  ==因此我们专注寻找最短的简单路径==. 



**Definition** 从源结点$s$可达的所有结点和它们的最短路径组成的是一个==最短路径树==. 



**松弛操作**

在每个结点上维护一个$v.d$表示源结点$s$到$v$的最短路径的上界，relax操作就是通过$v$的前驱结点来更新$v.d$和$v.p$，因为$s$到$v$总要通过$v$的前驱结点. 

```
init(G,s)
	for each v in G.V
		v.d = maximum
		v.p = nil
	s.d = 0	

relax(u,v,w)
	if v.d > u.d + w(u,v)
		v.d = u.d + w(u,v)
		v.p = u
```



一些有用的性质

**Proposition** ==三角不等式==  $\delta(s,v) \leq \delta(s,u) + w(u,v)$

**Proposition** ==路径松弛性质== 如果$p = <v_0, v_1,\cdots,v_k>$是从$v_0$到$v_k$的一条最短路径，如果我们按照$(v_0,v_1),\cdots ,(v_{k-1},v_k)$的次序依次做松弛操作，则$v_k.d$就是最短路径.  该性质与其他的松弛操作无关，即使有其他的松弛操作在里面.  就是必须做完前述的松弛操作之后才能得到最短路径. 



**Bellman-ford算法**

根据前面路径松弛的性质，要求一对结点$(v_0,v_k)$最短路径，若它们之间存在最短路径，那么只要按照这个最短路径的依次做松弛操作.  显然我们是不可能提前预知那一条是最短路径，因此考虑对$G$上所有边都做$|G.V|-1$（简单路径上最多有$|G.V|$个结点，因此最多有$|G.V|-1$条边）次relax操作，这样对每一对可达的结点而言，总有一个松弛序列对应它们的最短路径.  

它的优势是可以处理带负值的有向图.   

时间复杂度为$O(VE)$.

```python
bellman_ford(G,w,s)
	init(G,s)
	for i = 1 to |G.v|-1
		for each (u,v) in G.E
			relax(u,v,w)
	for each (u,v) in G.E #有结点的v.d可以任意小，代表有负权重的环
    	if v.d > u.d + w(u,v)
    		return false
    return true		
```



**DAG**算法

这个算法是针对==有向无环图==的改进.    其主要思想如果$u,v$之间存在一条简单路径，那么在拓扑序中$u$应位于$v$的前面，因此我们可以只需要按照拓扑序的来一次relax操作，就可以计算出源节点到所有可达结点的最短路径. 



```python
dag(G,w,s)
	linear_order = topologically_sort_graph(G)
    init(G,s)
	for each v in linear_order
    	for each u in v.adj
        	relax(v,u,w)            
```



**Dijkstra算法**

此时要求是有向图上所有的边的权重都是==非负的==.  Dijkstra算法本质是一个贪心算法，这里我们要对所有结点$v.d$维护一个最小队列.

主要步骤:

1.  初始化所有结点$v.d = \infty$，其源结点$s.d = 0$，这是为了第一个从$Q$里面拿$s$出来
2.  对所有结点按照$v.d$为关键字构造一个最小队列$Q$
3.  从$Q$里面去一个$v.d$最小的结点出来，加入到结点集合$S$中
4.  更新$v$的所有邻接的结点的$v.d$和$v.p$，同时维护$Q$
5.  重复34操作知道$Q$为空，得到$S$就是所有从$s$可达的结点$v$，其$v.d$表示$s$到$v$的最短路径. 

时间复杂度为$O(V^2 + E)$

Dijkstra算法依赖最小队列的实现，因此需要看一下关于改进最小队列的实现. 

```python
dijkstra(G,w,s)
	init(G,s)
	S = {}
	Q = build_minimum_queue(G.V)
	while Q != empty
		u = extract_min(Q) #此时最小队列extract_min操作时间我们可以理解为O(V), 而insert和delete_key认为是O(1)
		add(S,u)
		for each v in u.adj #这里总共花费的时间，可以理解为整张邻接链表. 
			relax(u,v,w)
```





