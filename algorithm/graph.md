# 图上的算法



### 0x00 图的定义



**基本定义**

用$G=(V,E)$表示一张图，其中$V$表示图中的结点，$E$表示图上两结点的边。 如果对某条具体的边进行区分，可以分为无向图和有向图。 根据$V$和$E$之间关系，若$|E| << |V|^2$ ，则称$G$是一个稀疏图，若$|E| \sim |V|^2$，则称$G$是一个稠密图。



### 0x01 图的两种表示



- 邻接链表

  把图上的所有的结点$V$用一张链表$L$连起来，其中$L$上每个的节点$v$又是一张链表$L_v$的头，表示从$v$出发的边所对应的结点，即$v \to u$，则$u \in L_v$.

- 邻接矩阵

  初始化一个$|V| \times |V|$ 零矩阵$A=\mathbf{0}$，若存在$u \to v \in E$， 则标记$A_{uv} = 1$，显然我们可能用正整数标记图上不同的结点。

两种表示方式都可以很自然的表示无向图和有向图，特别地如果是无向图，那么对应的邻接矩阵是一个对称矩阵。 



**偏向使用**

- 邻接链表
  - 稀疏图
  - 若查找$u \to v$，需要遍历$L_u$。
  - 空间存储为$O(|V|+|E|)$，存储空间使用上可能小于邻接矩阵，但渐进上是一样的。
  - 鲁棒性高。
- 邻接矩阵
  - 稠密图
  - 查找某条边是否存在是极为方便的。
  - 空间存储度为$ O(|V|^2)$，在无向图下，由于是对称矩阵，所以只需要对角线和对角线上放的空间。
  - 每个记录项只需要1位空间。



### 0x02 广搜

广度优先搜索是图上一种遍历算法:

1. 选择以某个源节点$s$为开始，初始化一个队列$Q$，把$s$的子节点都扔到里面，

2. 再依次从$Q$里面取节点出来探索，

3. 若碰到第一次探索的节点，则将所有的子节点也加到队列$Q$里面。

4. 直到$Q$为空时。

   

```python
BFS(G, s):
    for each vertex u in G.V-{s}:  # 初始化
        u.color = WHITE
        u.d = infinity
        u.pi = NIL
    s.color = GRAY
    s.d = 0
    s.pi = NIL
    Q = {}
    ENQUEUE(Q, s)
    while Q is not empty:
        u = DEQUEUE(Q)
        for each v in G.Adj[u]:
            if v.color == WHITE:
                v.color = GRAY
                v.d = u.d + 1
                v.pi = u
                ENQUEUE(Q, v)
        u.color = BLACK
```





**关于Coloring的介绍** 已经探索过的结点标记为黑色，未被探索但是为黑丝的边界结点标记为灰色，其余的结点标记为白色。

**关于结点属性d**  用$v.d$表示从当且广搜树根结点$s$到$v$的路径长度。



**Definition** 对于给定$G=(V,E)$和源结点$s$在广搜下，定义$G$的前驱子图为$G_\pi = (V_\pi,E_\pi)$，其中$V_\pi = \{v \in : v.\pi \neq NIL\} \cup \{s\},E_\pi = \{(v.\pi, v): v \in V-\{s\}\}$.  若$G_\pi$上每一个结点$s$都可达，且只包含唯一的简单路径，而且是最短路径，则称$G_\pi$是一个==广度优先树==（广度优先生成树）.  $E_\pi$中的边称为树边。

**Lemma**  BFS会生成一个广度优先树。

**Definition** 在广搜的过程中，若在探索$u \to v$，其中$v$是白色结点，则在对应的广搜树中，称$u$是$v$的前驱或者父节点，记为$u = v.\pi$。 

**Definition** 记$\var(s,u)$表示$G$ 上$s$到$u$之间的最短路径。

**Theorem** 以源结点$s$为根结点的广搜树上的结点$v$，都是$G$上可以由$s$可达的，且树上$s \leadsto v$是$G$上$s$到$v$的==最短路径==. 特别地若$u$是$v$的前驱，则

$\var(s,v) = \var(s,u)+1$。

**Lemma** 给定$G=(V,E)$，设$s \in V$，则对任意边$(u,v) \in E$，有$\var(s,v) \leq \var(s,u) + 1$。 

这是一个有趣的bounder，无所谓$s$与$u,v$是否可达。

**Lemma** 对广搜树上任意的结点$v$，都有$\var(s,v) \leq v.d$.   

只要证明这个上界等号是成立的，则可以说明广搜得到的确实是最短路径。 

**Lemma** 在广搜的过程中任意深刻队列$Q$中最多只包含两个不同的$d$值，即考虑$Q=\{v_1,\cdots,v_r\}$，则有$v_r.d \leq v_1.d+1$，同时有

$v_i \leq v_{i+1}, i = 1,\cdots,r_1$.   换句话说$v_i.d$不降，且也不大于最后一个结点$v_1.d+1$，这是更为强的一个结论。

这是刻画广搜总是从边界水平向外推进的最根本的的原因， 需要考虑$Q$在入列和出列时操作。 

**Lemma** 在广搜的过程中若$v_i$比$v_j$先入列，且它们在某一时刻都在队列$Q$里面，则$v_i.d \leq v_j.d$ 。







### 0x03 深搜

深度优先搜索的步骤：

1. 选择以某个源结点$s$，选择它最近的出发边进行探索，
2. 对每一个的结点（无论是新的或者探索过的），都会选择它最近的出发边，且该出发边对应的端点没有被探索过进行探索。（DFS-VISIT）
3. 若新发现的结点没有出发边，则回到它在搜索过称的前驱结点进行继续探索。
4. 若$s$的出发边都被探索完毕，则在$G$上选择一个没有被探索过的结点继续探索。 （DFS）



````python
DFS(G):
    for each vertex u in G.V:  # 初始化
        u.color = WHITE
        u.pi = NIL
    time = 0
    for each vertex u in G.V:
        if u.color == WHITE:
            DFS-VISIT(G, u)  # 以u为源结点进行深度优先探索
            
DFS-VISIT(G, u):
    time = time + 1
    u.d = time
    u.color = GRAY            # 发现
    for each v in G.Adj[u]:   # 探索u的邻接结点
        if v.color == WHITE:  # 若发现新的未探索结点
            v.pi = u
            DFS-VISIT(G, v)   # 优先递归探索新的结点v
            # 探索完v后，循环继续进行，探索u的下一个邻接结点
    u.color = BLACK
    time = time + 1
    u.f = time                # 探索完成            
````



**关于时间区间** 将$v$第一次被发现的时间记为$v.d$，完成对$v$所有出发边并回到$v$时的时间记为$v.f$. 

**关于Coloring的介绍** 已经探索完成的的结点标记为黑色，出发边还没有探索完毕的结点标记为灰色，其余的结点标记为白色。



**Theorem** $G=(V,E)$在深搜下， 对于任意$u,v \in V$, 仅满足下述三种关系中的一种

1. 若$[u.d,u.f] \subset [v.d,v.f]$ ，则$u,v$在同一棵深度优先树中，且$u$是$v$的子孙结点;
2. 若$[v.d,v.f] \subset [u.d,u.f]$ ，则$u,v$在同一棵深度优先树中，且$v$是$u$的子孙结点;
3.  若$[v.d,v.f]$和$ [u.d,u.f]$ 完全分离，则$u,v$不在同一颗深度优先树中。



**Definition** 当DFS-VISIT生成以$u$为根结点的树称为深度优先树，即$T_u = (V_u, E_u)$，其中$V_u = \{v \in V: u.d < v.d < v.f < u.f \} \cup \{u\}, ~ E_u = \{(v.\pi,v): v \in {V_u}-{u}\}$.   

**Definition** 在深搜下，$G$的前驱子图定义为$G_\pi = (V,E_\pi)$，其中$E_\pi = \{(v.\pi,v): v.\pi \neq NIL\}$.   $G_\pi$是由多个深度优先树构成的深度优先森林。







### 0x04 强连通分量



### 0x04 拓扑序









