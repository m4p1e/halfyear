# 字符串模式匹配



### 0x00 提出问题

字符匹配问题的形式化定义

假设文本是一个长度为$n$的数组$T[1\cdots n]$，而模式是一个长度为$m$的数组$P[1\cdots m]$，其中$m \leq n$.  进一步假设$P$和$T$所含字符均来自于同一有限字母集$\sum$.   

1.  如果$0 \leq s \leq n-m$，并且$T[s+1,s+m] = P[1,m]$， 则称模式$P$在文本$T$中出现，且偏移为$s$. 
2.  如果$P$在$T$中以偏移$s$出现，那么称$s$是有效偏移. 否则称它是无效的. 



### 0x01朴素算法

时间复杂度为: $O(m(n-m+1))$



```python
navie_string_match(T,P)
	n = T.length
	m = p.length
	for s=0 to n-m
    	if compare(T,s,P) == true
    		print "found" 		
```



### 0x02 RK算法

现在统一假设字符串的字母集为$\{0,1,\cdots,9\}$，其中每个数字看做一个字符.   



**简单情况**

若$P$的长度$m$比较短，且将其转换至十进制的数字在计算机字的长度内，也就是说$P$的长度比较小，那么我们可以使用这样的算法

1. 计算$P$的十进制数字表示$p$.
2. 计算$n-m+1$个子串$T[s+1\cdots s+m ]$的数字表示$t_s$
3. 将$p$依次与$t_s$比较. 

对于$P$计算$p$，可以在时间$O(m)$完成，低位在$P[m]$. 
$$
p = P[m] + 10(P[m-1]+10(P[m-2]+\cdots+10(P[2]+10P[1])\cdots))
$$
对于计算$t_s$，可以使得在常数时间内根据$t_s$计算出$t_{s+1}$，在时间$O(n-m+1)$内计算出所有的$t_s$
$$
t_{s+1} = 10(t_s - 10^{m-1}*T[s+1])+T[s+1+m]
$$
实际上就是先减去高位，再左移补上最低位. 



**一般情况**

最坏情况下所需时间为$O(m(n-m+1))$. 

算法的期望时间为$O(n+m)$. 



若不限制$P$的长度$m$，显然比较两个任意的长度数字是不实际的，因此这里考虑一个启发式的算法:

1.  选择一个合适的模数$q$.
2.  与简单情况一样计算$p$和$t_s$，并对它们模上$q$.  模出来的余数再作为对应的$p$和$t_s$. 
3.  若$p$和$t_s$相等，则其对应的字符串有可能是相同的; 若$p$和$t_s$不相等，则其对应的字符串一定是不相同的. 
4.  在$p$和$t_s$相等下，我们做进一步的字符串的比较，来确定是否相同. 



这里假设是$d$进制字母表，这里需要调整一下计算$t_{s+1}$的算法. 
$$
t_{s+1} = \left[ d(t_s - d^{m-1}*T[s+1])+T[s+1+m]\right]~\text{mod}~q
$$
为简化计算可以先$d^{m-1}~\text{mod}~q$来替换上式的$d^{m-1}$. 





### 0x03 有限自动机算法

一个有限自动机$M$是一个5元组$(Q,q_0,A,\sum,\var)$，其中

- $Q$表示状态集合
- $q_0\in Q$是初始状态
- $A \subseteq Q$表示一个接受状态集合
- $\sum$ 是有限输入字母表
- $\var$表示函数$Q \times \sum \to Q$，称为转移函数. 

为了方便说明问题，可以递归定义一个终态函数$\phi(w) : \sum^* \to Q$，就是指$M$接受了字符串$w$之后最终落入了哪个状态，其递归定义为
$$
\phi(\varepsilon) = q_0, \\
\phi(wa) = \var(\phi(w),a)
$$


**Definition** 若字符串$w$是$x$的前缀，则记为$w \sqsubset x $，反之若$w$是$x$的后缀，则记为$w \sqsupset x$.

定义函数$\sigma_P(w) : w \to \{1,2,\cdots,m\}$表示$w$的后缀中蕴含$P$的最长子串的长度，即
$$
\sigma_P(w) = \max\{k: P_k \sqsupset x\}
$$
例如设$P=ab$，则$\sigma_P(\varepsilon)= 0,\sigma_P(ccaca) = 1,\sigma_P(ccab) = 1$.



**Proposition** 对于一个长度为$m$的模式$P$，$\sigma_P(w) = m$当且仅当$P \sqsupset w$. 



最主要是如何从对一个模式$P$生成一个字符串匹配自动机?

对于给定模式$P=[1\cdots m]$

1. 状态集合为$\{1,2,\cdots,m\}$. 开始状态$q_0 = 0$，并且状态$m$是唯一接受的状态.

2. 对于任意的状态$q$和字符$a$，转移函数定义为$\var(q,a) = \sigma_P(P_qa)$. 


 

**Lemma** 对任意的字符串$w$和字符$a$，有$\sigma_P(wa) \leq \sigma_P(w) +1$.

**Lemma** 对任意的字符串$w$和字符$a$，若$q=\sigma_P(w)$，则$\sigma_P(wa) = \sigma_P(P_qa)$. 

**Proposition** 上述定义的自动机，有等式$\phi(T_i) = \sigma_P(T_i)$成立，其中$T_i$表示$T$的一个子串. 



生成转移函数的代码

```python
generate_transfer_function(P,C)
	m = P.length
	for q = 0 to m
		for a in C 
        	k = min(m+1,q+2) #这样做的目的是考虑最大的可能的P子串，+2是后面会首先减1. 我们考虑的最长子串只能是P本身. 
            repeat
            	k=k-1
            until P_k is longest suffix string of P_qa
            transfer_func(q,a) = k
    return transfer_func        
```



需要$O(m|\sum|)$的预处理时间和$O(n)$的匹配时间. 



### 0x04 KMP

这个算法比较神奇，不需要转移函数，也能实现$O(n)$的匹配时间.  其关键在于在失败匹配之后，我们根据某些信息跳过一些字符串

![image-20210917174022467](/home/maple/halfyear/images/image-20210917174022467.png)

上面利用了$P_3$是$P_5$的最长后缀子串.  这些信息我们都是可以提前计算出来，我们可以用一个$\pi$数组来记录，例如这里可以使得$\pi[5]=3$，那么在$P_6$匹配失败之后，也就是已经成功匹配了$P_5$，我们将匹配的指针往后移动$5-\pi[5]$.



那么如何设计这个$\pi$呢？ 也就是说当已经成功匹配了$P_q$之后，紧着失败了，那么最小的偏移应该是多少？最小的偏移等价于找到最长的后缀子串.  形式化地可以解释为给定子串$P_q$，求满足$P_k \sqsubset P_q$的$k$的最大值.  即
$$
\pi[q] = \max\{k : P_k \sqsubset P_q\}
$$
这个算法是比较好设计的，只需要从$k$的最大值$q-1$开始来尝试.  













