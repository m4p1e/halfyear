# 字符串模式匹配



### 0x00 提出问题

字符匹配问题的形式化定义

假设文本是一个长度为$n$的数组$T[1\cdots n]$，而模式是一个长度为$m$的数组$P[1\cdots m]$，其中$m \leq n$.  进一步假设$P$和$T$所含字符均来自于同一有限字母集$\sum$.   

1.  如果$0 \leq s \leq n-m$，并且$T[s+1,s+m] = P[1,m]$， 则称模式$P$在文本$T$中出现，且偏移为$s$. 
2.  如果$P$在$T$中以偏移$s$出现，那么称$s$是有效偏移. 否则称它是无效的. 



### 0x01朴素算法

时间复杂度为: $O(m(n-m+1))$



```python
navie_string_match(T,P)
	n = T.length
	m = p.length
	for s=0 to n-m
    	if compare(T,s,P) == true
    		print "found" 		
```



### 0x02 RK算法

现在统一假设字符串的字母集为$\{0,1,\cdots,9\}$，其中每个数字看做一个字符.   



**简单情况**

若$P$的长度$m$比较短，且将其转换至十进制的数字在计算机字的长度内，也就是说$P$的长度比较小，那么我们可以使用这样的算法

1. 计算$P$的十进制数字表示$p$.
2. 计算$n-m+1$个子串$T[s+1\cdots s+m ]$的数字表示$t_s$
3. 将$p$依次与$t_s$比较. 

对于$P$计算$p$，可以在时间$O(m)$完成，低位在$P[m]$. 
$$
p = P[m] + 10(P[m-1]+10(P[m-2]+\cdots+10(P[2]+10P[1])\cdots))
$$
对于计算$t_s$，可以使得在常数时间内根据$t_s$计算出$t_{s+1}$，在时间$O(n-m+1)$内计算出所有的$t_s$
$$
t_{s+1} = 10(t_s - 10^{m-1}*T[s+1])+T[s+1+m]
$$
实际上就是先减去高位，再左移补上最低位. 



**一般情况**

最坏情况下所需时间为$O(m(n-m+1))$. 

算法的期望时间为$O(n+m)$. 



若不限制$P$的长度$m$，显然比较两个任意的长度数字是不实际的，因此这里考虑一个启发式的算法:

1.  选择一个合适的模数$q$.
2.  与简单情况一样计算$p$和$t_s$，并对它们模上$q$.  模出来的余数再作为对应的$p$和$t_s$. 
3.  若$p$和$t_s$相等，则其对应的字符串有可能是相同的; 若$p$和$t_s$不相等，则其对应的字符串一定是不相同的. 
4.  在$p$和$t_s$相等下，我们做进一步的字符串的比较，来确定是否相同. 



这里假设是$d$进制字母表，这里需要调整一下计算$t_{s+1}$的算法. 
$$
t_{s+1} = \left[ d(t_s - d^{m-1}*T[s+1])+T[s+1+m]\right]~\text{mod}~q
$$
为简化计算可以先$d^{m-1}~\text{mod}~q$来替换上式的$d^{m-1}$. 





### 0x03 有限自动机算法



### 0x04 KMP

