# 复杂度的计算 



### 0x00  渐进的概念

为什么复杂度的概念存在?

当输入规模无限增加时，在极限中，算法的运行实际如何随着输入规模的变大而增加.  也就是研究算法的渐进效率. 



**Definition** 给定一个函数$g(n)$，用$\Theta(g(n))$表示满足下述条件所有函数的集合:  存在常数$c_1,c_2$和$N$，使得对所有的$n \geq N$时，有
$$
0 \leq c_1g(n) \leq f(n) \leq c_2g(n)
$$
我们称$g(n)$是$f(n)$的一个==渐进紧确界==. 相当给出了于$f(n)$的一个上界和一个下界，而且只相差常数项的系数. 



**Definition**  给定一个函数$g(n)$，用$O(g(n))$表示满足下述条件所有函数的集合:  存在常数$c$和$N$，使得对所有的$n \geq N$时，有
$$
0 \leq f(n) \leq cg(n)
$$
我们称$g(n)$是$f(n)$的一个==渐进上界==.  通常叫做大O表示法. 



**Definition**  给定一个函数$g(n)$，用$\Omega(g(n))$表示满足下述条件所有函数的集合:  存在常数$c$和$N$，使得对所有的$n \geq N$时，有
$$
0 \leq cg(n) \leq f(n)
$$
我们称$g(n)$是$f(n)$的一个==渐进下界==.



**Proposition** 对于给定的两个函数$f(n)$和$g(n)$，若$f(n) \in \Theta(g(n))$当且仅当$f(n) \in O(g(n))$且$f(n) \in \Omega(g(n))$. 



**Definition**  给定一个函数$g(n)$，用$o(g(n))$表示满足下述条件所有函数的集合:  对任意的常数$c > 0$，存在常数$N$，使得对所有的$n \geq N$时，有
$$
0 \leq f(n) < cg(n)
$$
我们称$g(n)$是$f(n)$的一个==非渐进上界==.  通常叫做小O表示法. 



**Definition**  给定一个函数$g(n)$，用$\omega(g(n))$表示满足下述条件所有函数的集合:  对任意的常数$c > 0$，存在常数$N$，使得对所有的$n \geq N$时，有
$$
0 \leq cg(n) < f(n)
$$
我们称$g(n)$是$f(n)$的一个==非渐进下界==.



**Proposition** 所有渐进符号都满足传递性.  

**Proposition** 转置对称性
$$
f(n) = O(g(n)) ~\text{if and only if}  ~g(n)=\Omega(f(n)) \\
f(n) = o(g(n)) ~\text{if and only if}  ~g(n)= \omega(f(n)) \\
$$


**Proposition** 常见性质

1. $f_1(n) + f_2(n) \in O(\max(f_1(n),f_2(n)))$
2. $f_1(n) \times f_2(n) \in O(f_1(n) \times f_2(n))$



### 0x01 复杂度

算法的复杂度分为两种	

1. 时间复杂度 执行算法所需要的计算工作量

2. 空间复杂度  执行这个算法所需要的内存空间

   

**基本操作**

同一个算法在不同的计算机上运行的速度会有一定的差别，并且实际运行速度难以在理论上进行计算，实际去测量又比较麻烦，所以我们通常考虑的不是算法运行的实际用时，而是算法运行所需要进行的基本操作的数量。

在普通的计算机上，加减乘除、访问变量（基本数据类型的变量，下同）、给变量赋值等都可以看作基本操作。

对基本操作的计数或是估测可以作为评判算法用时的指标。




**渐进符号的使用**

我们在研究算法复杂度的时候，通常只会考虑其上界，往往就是算法最坏情况，但也有时候会考虑算法的期望情况.   显然$\Theta$和$O$都可以用来表示某个算法的上界，且前者更为精确，但是有时候我们不能证明某个时间T是是同时满足渐进上下界的，因此用$O$多一点.   



### 0x02 考点

1. 求所给函数的5个bounder
2. 给定多个函数，它们表达式的5个bounder
