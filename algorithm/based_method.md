# 一些算法的基本思想



### 0x00 分治法

在分治策略中，我们递归地求解一个问题，在每层递归中需要应用如下三个操作:

1. 分解 将问题划分为更小的一些子问题，子问题的形式与原问题一样，只是规模更小.
2. 解决 递归的求解子问题，如果子问题规模足够小，则停止递归，直接求解
3. 合并 将子问题的解组合成原问题的解



使用==递归式==来描述问题分解的过程和分解所需要的时间.

求解递归式的三种方法:

1. 带入法
2. 递归树法
3. 主方法 



### 0x01 动态规划

分治法用于把一个原问题分解成几个互不相机的相同类型的子问题，递归的求解子问题。 与之相反，动态规划用于子问题重叠的情况，在这种情况下，分治法会做出许多不必要的工作，它反复求解公共的子问题. 而动态规划会对这样公共子问题只计算一次，然后将其解保存下来，后续再碰到该子问题时，无需重新计算.



通常会按照下述步骤来设计一个动态规划算法:

1. 刻画一个最优解的结构特征
2. 递归定义最优解的值
3. 计算最优解的值，通常采用自底向上的方法
4. 利用计算出的信息构造一个最优解



**Definition** 若问题的最优解可以由相关的子问题的最优解组合而成，而这些子问题都可以独立求解，我们则称该原问题满足==最优子结构==.



动态规划的两种等价的实现方式

1. 带备忘的自顶向下方法   

   此方法按照自然的递归形式编写过程，但过程会保持每个子问题的解. 当需要一个子问题的解时，过程首先检查是否已经保持过此解. 如果是，则直接返回保持的值，从而节省了计算时间.   这里大大的缓解了完成的递归过程. 

2. 自底向上法

   若任何子问题只依赖于更小的问题，则可以将子问题按规模排序，按从小至大的顺序进行求解.  当求解某个子问题时，它所依赖的那些更小的子问题都已经求解完毕.  因此每个子问题只需要求解一次.  这种方法不需要递归求解，所以没有频繁递归函数调用的开销. 



子问题图表示子问题相互的依赖关系. 



什么时候应该采用最优子结构？ 满足两个要素

1. 最优子结构
2. 子问题重叠 
3. 子问题无关性  两个子问题求解之间相互影响

 

对于算法的运行时间

可以通过==子问题的总数==和==每个子问题需要考察多少种选择==（最多）选择两个因素的乘积来粗略分析算法的运行时间. 



4个例子

1. 切钢筋
2. 矩阵乘法加括号
3. 最长公共子序列
4. 最优二叉搜索树



### 0x02 贪心法

如果在算法的每一步都做出当前看起来是最优的选择，即它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解.  是否能得到区间最优的解，是需要严格证明的，贪心法不一定能保证全局的最优性.  



主要思想： 如果我们正在处理最优化问题时，如果该问题具有最优子结构，那么我们可以尝试把原问题分解成一个一个的子问题，这样我们需要考虑每个子问题的最优解，贪心算法的思想是我们可以不同去思考所有的子问题，我们只需要做出一次选择就行。 这样的做法是需要建立在完全正确的证明上的. 

主要步骤

1. 确定问题的最优子结构
2. 设计一个递归算法
3. 证明如果我们做出一个贪心选择，则只剩下一个子问题
4. 证明贪心选择总是安全的
5. 设计一个递归算法实现贪心策略
6. 将递归算法转换为迭代算法



例子

1. 活动选择
2. 0-1背包 不能用贪心，只能动态规划
3. 分数背包 可以用贪心



