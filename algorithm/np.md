# NP 完全性（Non-Deterministic Polynomial Time ）



### 0x00 基本概念



**多项式时间的算法** 

对于规模为$n$的输入，在最坏情况下的运行时间是$O(n^k)$，其中$k$为某一确定尝试. 



**问题的引入**

是否所有问题都可以在多项式时间内被解决？ 答案是否定的.

著名的停机问题

```python
halt(P,I) #给定一个特定程序P和输入I，判定P是否会在有限的时间内结束运行，若可以在有限时间内返回，则返回true，否则返回false. 

foo(P){
    while(halt(P,P)){
        #dead loop
    }
}

halt(foo(P)) #??? 会正常返回吗？
```



**问题分类**

- P类问题  可以在多项式时间内解决的问题
- NP类问题 可以在多项式时间内验证的问题（验证给定一个问题的答案，判定它是否满足当且问题）
- NPC类问题 是NP类问题的一个子集，且解决其他的任意NP问题所需的时间不会超过解决一个NPC问题所需的时间乘上一个多项式因子.  这就意味着若我们能在多项式时间内解决某个NPC问题，那么就能解决所有NP问题. 



**问题之间的关系**

- P是属于NP的，但是P是否是NP的真子集这是未知的！



**认定的一个事实**

如果任何NPC问题可以在多项式时间内被解决，那么所有NP问题都有一个多项式时间算法.



### 0x01 多项式时间



**Definition**  若某个问题的答案是简单的true或者false，或者更形式化的1或0，则称该问题是一个==判定问题==（decision problem）

**Definition**  称某一特定问题的输入为该问题的一个==实例==（instance）

**Definition**  给一个判定问题A，若存在一个不同的，但可以在多项式时间内被解决的判定问题B（多项式时间的归约是否需要保证这第二个问题是多项式时间可以解决的），并且存在下面这样的一个过程

1. 可以在多项式时间将A的任何实例$\alpha$转换成B的一个实例$\beta$.
2. 两个实例$\alpha$和$\beta$具有相同的解，即$\alpha$的解是1当且仅当$\beta$的解是1. 

我们则称这一过程为多项式时间的==归约算法==.  A is at least as hard as B

==归约概念的提出更像是在划分等价类，我们如果解决了其中一个问题，那么其所在的等价类里面的问题解决所需时间只相差一个多项式因子==. 



**如何利用归约概念来描述一个问题是不存在多项式时间的**？ 

反用归约: 假设有一个判定问题A，我们已经知道了它不可能存在多项式时间算法.  进一步假设有一个多项式时间的归约，它将A的一个实例转化为了B的实例.  那么我们可以用反证法来证明B不可能存在多项式时间算法. 



**判定问题和最优化问题的之间微妙的联系**

最优化问题在某些程度上是可以转换为一个判定问题，例如在求最短路径的过程中，我们可以引入一个关于路径的判定问题

“Q: 给定一个有向图G，顶点u和v， 一个整数k，在u和v之间是否存在一个至多包含k条边的路径？”

显然我们可以多次处理这个路径判定问题来求解最短路径问题. 

==NP完全性理论主要着眼于判定问题==.



**形式化地定义多项式时间**

**Definition** 抽象问题$Q$为问题实例集合$I$ 和问题解集合$S$的一个二元关系，即$Q \subseteq I \times S$. 

**Definition** 以二进制串集合为实例的问题称为具体问题.  

**Definition** 若对于某个用于解决具体问题的算法，提供给该算法长度为$n = |i|$的一个问题实例，该算法可以在$O(T(n))$时间内给出问题的解，我们就说该算法在时间$O(T(n))$内解决该问题.

**Definition** 若一个具体问题是多项式时间内可解，则存在一个算法可以在$O(n^k)$时间内解决该问题. 

**Definition** 把多项式时间内可解的具体判定问题组成的集合称为==复杂类 P==（complexity class P）

**Definition** 抽象对象集合$S$的==编码==（encodings）是$S \to S$到二进制串集合的一个映射$e$.

**Definition** 用$e(Q)$表示一个抽象问题到具体问题的映射，即实际上$e: I \to \{0,1 \}^*$，且某个抽象问题的实例$i \in I$，对应具体问题实例$e(i)$，它们两个的解是相同.  

**Definition** 给定一个二进制串上的函数$f: \{0,1\}^* \to \{0,1\}^*$，如果存在一个多项式时间的算法A，它对任意给定的输入$x \in \{0,1\}^*$，都能产生输出$f(x)$，则称该函数是一个==多项式时间可计算==的函数.  换句话说算法A是$f$的一个多项式时间内的表示. 

**Definition** 如果存在两个多项式时间可计算的函数$f_{12}$和$f_{21}$满足对任意$i \in I$，有$f_{12}(e_1(i)) = e_2(i)$和$f_{21}(e_2(i)) = e_1(i)$成立，我们则称$e_1$和$e_2$是==多项式相关==.  换句话就是$e_2(i)$可以由一个多项式算法根据$e_1(i)$求出.



**Lemma** 设$Q$是定义在一个实例集$I$上的一个抽象判定问题，$e_1$和$e_2$是$I$上多项式相关的编码，则$e_1(Q) \in P$当且仅当$e_2(Q) \in P$. 



**为什么要引入编码？**

我们希望通过编码的方式把多项式时间可解性从具体问题扩展到抽象问题，但同时希望这一定义与任何特定的编码无关，即求解一个问题的效率不应依赖于问题的编码. 遗憾是的这种依赖性是比较严重的，但是如果不指定编码就无法真正的谈论对一个抽象问题的求解.   

退而求其次，我们可以归纳出来某些编码对问题的复杂度作用是等价的，因此只要我们确定一种标准对问题复杂度没有影响的编码，我们可以很快的通过它推导出其他的编码方式（数学对象），对问题的复杂度均是没有影响的。 我们尽可能的在他们的作用下再去谈论复杂性，同时这个他们也给了我们很多选择. 



**形式语言的框架下描述判定问题**

形式语言中相关理论

1. 字母表$\Sigma$ 是符号的有限集合.
2. 字母表上的语言$L$ 是由表中符号组成的串的任意集合



**Definition** 任意的判定问题$Q$可以看做定义在$\Sigma=\{0,1\}$上的一个语言$L$，其中
$$
L = \{x \in \Sigma^* : Q(x) = 1\}
$$
**Definition** 对于某个问题的算法$A$，如果输入$x$，算法输出$A(x)=1$，则称$A$接受$x$，反之则称$A$拒绝$x$. 将所有被$A$接受的字符串记为一个集合，即
$$
L = \{x \in \Sigma^* : A(x) = 1\}
$$
我们称语言$L$是被算法$A$所==接受的==.



**Remark** 即使语言$L$被$A$所接受，那么$A$也不一定就拒绝一个输入$x \notin L$.  因为有可能$A$在输入$x$下陷入死循环. 



**Definition** 如果$L$中每个二进制串都可以确定地被算法$A$接受或者拒绝，则称语言$L$由算法$A$==判定==. 

**Definition** 若存在常数$k$，使得对任意长度为$n$的串$x \in L$，算法$A$在时间$O(n^k)$ 内接受$x$，则称语言$L$在多项式时间内被算法$A$==接受==. 

**Definition** 若存在常数$k$，使得对任意长度为$n$的串$x \in \Sigma^*$，算法$A$在时间$O(n^k)$ 内判定$x \in L$，则称语言$L$在多项式时间内被算法$A$==判定==. 



下面这个定义是很显然的. 

**Definition** $P = \{L: \text{存在一个算法$A$，可以在多项式时间内判定$L$}\}$. 

**Lemma** “多项式时间内能被判定的语言类”是“多项式时间内能被判定的语言类”的一个子集

**Theorem** $P = \{L: L~\text{能被一个多项式时间算法$A$所接受}\}$。

*Proof.*  在$A$的基础上构造一个算法$A'$，使得$A'$可以在多项式时间内判定$L$. 

**Theorem** 类$P$在被看做是一个语言集合时，在并集，交集，连接，补集和取闭包的情况下都是封闭的.



 **验证算法**

**Definition** 由一个验证算法$A$所验证的语言为
$$
L = \{x \in \{0,1\}^* : \text{存在$y \in \{0,1\}^*$, 满足$A(x,y)=1$} \}
$$
这个$y$是个什么东西?  $y$被称为一个certificate(证书). 例如两个结点的简单路径长度的判定问题，给定一个实例$(G,u,v,k)$，同时给定从一条从$u \to v$的路径$p$，我们可以很容易的检查p的长度是否小于等于$k$，如果是，那么就可以把$p$看做一个certificate. 

**Definition** ==复杂类NP==是能被一个多项式时间算法验证的语言类. 更确切地说，一个语言$L$属于$NP$，当且仅当存在一个多项式验证算法$A$和常数$c$，满足
$$
L = \{x \in \{0,1\}^* : \text{存在$y \in \{0,1\}^*,|y|=O(|x|^c)$, 满足$A(x,y)=1$} \}
$$
**多项式时间归约**

归约的定义前面已经写了。 

**Definition** 若语言$L_1$在多项式时间内可以归约为语言$L_2$，记为$L_1 \leq_q L_2$. 

**Remark** $L_1$及$L_2$分别对应一个判定问题$Q_1$及$Q_2$，在$L_1 \leq_q L_2$意义下表示，$Q_1$并不比$Q_2$难解决. 

**Definition** 若存在一个多项式时间可计算的函数$f$，满足$x \in L_1$当且仅当$f(x) = L_2$，则称$f$==归约函数==，计算$f$的多项式时间算法$F$称为==归约算法==.



**NP完全性**

**Lemma** 如果$L_1,L_2 \subseteq \{0,1\}^*$是满足$L_1 \leq_q L_2$的语言，则$L_2 \in P$蕴含着$L_1 \in P$. 



**Definition** 若语言$L$满足下述条件

1. $L \in $ NP
2. 对每一个$L' \in \text{NP}$，有$L' \leq_p L$

则称$L$是NP完全的.  若$L$仅满足性质2，但不一定满足性质1，则称==$L$是NP-hard的==. 



关于性质2的理解

NP到NPC的归约可以理解，主要在纠结P归约为NP是个什么意思？ 例如所有的P类判定问题都可以归约为停机问题，只需要把$P$问题的算法作为停机问题的算法的输入即可. 归约只是要求问题实例之间存在一个映射关系，并且在这种映射关系下，对应的两个问题实例的解都是相同的。 前面也提到了，从多项式时间的归约$Q_1 \to Q_2$里面得到的信息是解决$Q_1$大于$Q_2$的难度不会超过一个多项式因子.  NPC在描述的NP中最难的那一批问题. 



**Theorem** 如果任何NP完全问题是多项式时间可求解的，则P = NP. 等价地，如果存在某一NP中的问题不是多项式可求解的，则所有NP完全问题都不是多项式时间可求解的.   





**如何证明一个问题是NPC**？



**Lemma** (1) 如果语言$L$满足对任意地$L' \in \text{NPC}$ 都有$L ' \leq_P L$，则$L$是NP-hard.  (2) 此外，若$L \in \text{NP}$，则$L \in \text{NPC}$.

*Proof*.  （1）由$\leq_P$的传递性即可推广到所有的NP类语言上. （2）定义



我们的证明问题是NP完全的步骤为

1. 证明$L \in \text{NP}$
2. 选取一个已知的NP完全语言$L'$
3. 描述一种可计算函数$f(x)$的算法，其中$f$将$L'$的每一个实例$x$都映射到$L$中的某一个实例$f(x)$.
4. 证明函数$x \in L'$当且仅当$f(x) \in L$.
5. 证明计算函数$f$的算法具有多项式时间. 



历史上被证明的一个NP完全问题是布尔公式的满足性.   关于它的证明，显然它是NP的，完全性可以借助电路的可满足性来证. 



### 0xFF 证明电路可满足性问题属于NPC

**Definition** 如果一个单输出的布尔组合电路(由and，or，not组成逻辑电路)存在某个真值赋值使得电路输出为1，则称该布尔组合电路是==可满足的==. 

**Definition** 判定给定某个单输出的布尔组合电路是否可满足被称为==电路可满足性问题==，若将每个电路$C$映射为一个二进制串$\left<C\right>$，该串的长度与电路本身的规模破呈多项式关系，作为一种形式语言，我们可以定义
$$
\text{CIRCUIT-SAT} = \{\left< C \right>: C~\text{是一个可满足的布尔组合电路}\}
$$


**Lemma** $\text{CIRCUIT-SAT} \in \text{NP}$

*proof*. 给定真值赋值，那么验证算法$A$可以为沿着电路$C$计算每个逻辑门的结果即可，最后的逻辑门输出$1$，那么该算法也输出$1$，反之则输出$0$. 这一算法过程是和电路的规模呈多项式关系的，甚至可以达到线性关系.  如果$C$是可满足的，那么一定存在某个与$|C|$呈多项式长度的真值赋值 $y$作为certificate，使得$A(C,y)$.



**Lemma** $\text{CIRCUIT-SAT} \in \text{NPC}$

*proof*.  设$ L \in \text{NP}$，那么一定存在某个多项式验证算法$A$，它可以在多项式时间内验证$L$.  这个验证算法$A$运行在计算机上，那么一次运行过程$A(x,y)$实际对应了底层的某个电路$C$.  因此我们可以构造一个归约函数$C=f(x)$使得$A(x,y) = C(y)$，该电路规模$C$和算法$A$是成多项式关系的，因此$f$是一个多项式时间函数.  



 