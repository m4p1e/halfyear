# NP 完全性（Non-Deterministic Polynomial Time ）



**多项式时间的算法** 

对于规模为$n$的输入，在最坏情况下的运行时间是$O(n^k)$，其中$k$为某一确定尝试. 



**问题的引入**

是否所有问题都可以在多项式时间内被解决？ 答案是否定的.



著名的停机问题

```python
halt(P,I) #给定一个特定程序P和输入I，判定P是否会在有限的时间内结束运行，若可以在有限时间内返回，则返回true，否则返回false. 

foo(P){
    while(halt(P,P)){
        #dead loop
    }
}

halt(foo(P)) #??? 会正常返回吗？
```



**问题分类**

- P类问题  可以在多项式时间内解决的问题
- NP类问题 可以在多项式时间内验证的问题（验证给定一个问题的答案，判定它是否满足当且问题）
- NPC类问题 hard in NP



**问题之间的关系**

- P是属于NP的，但是P是否是NP的真子集这是未知的！
- 



**认定的一个事实**

如果任何NPC问题可以在多项式时间内被解决，那么所有NP问题都有一个多项式时间算法.



**规约**

**Definition**  若某个问题的答案是简单的true或者false，或者更形式化的1或0，则称该问题是一个==判定问题==（decision problem）

**Definition**  称某一特定问题的输入为该问题的一个==实例==（instance）

**Definition**  给一个判定问题A，若存在一个不同的，但可以在多项式时间内被解决的判定问题B，并且存在下面这样的一个过程

1. 可以在多项式时间将A的任何实例$\alpha$转换成B的一个实例$\beta$.
2. 两个实例$\alpha$和$\beta$具有相同的解，即$\alpha$的解是1当且仅当$\beta$的解是1. 

我们则称这一过程为多项式时间的==归约算法==.

==归约概念的提出更像是在划分等价类，我们如果解决了其中一个问题，那么其所在的等价类里面的问题都是可以被解决的==. 



**如何利用归约概念来描述一个问题是不存在多项式时间的**？ 

反用归约: 假设有一个判定问题A，我们已经知道了它不可能存在多项式时间算法.  进一步假设有一个多项式时间的归约，它将A的一个实例转化为了B的实例.  那么我们可以用反证法来证明B不可能存在多项式时间算法. 





**判定问题和最优化问题的之间微妙的联系**

最优化问题在某些程度上是可以转换为一个判定问题，例如在求最短路径的过程中，我们可以引入一个关于路径的判定问题

“给定一个有向图G，顶点u和v， 一个整数k，在u和v之间是否存在一个至多包含k条边的路径？”

显然我们可以多次处理这个路径判定问题来求解最短路径问题. 

==NP完全性理论主要着眼于判定问题==.



**形式化地定义多项式时间**

**Definition** 抽象问题$Q$为问题实例集合$I$ 和问题解集合$S$的一个二元关系，即$Q \subseteq I \times S$. 

**Definition** 以二进制串集合为实例的问题称为具体问题.  

**Definition** 若对于某个用于解决具体问题的算法，提供给该算法长度为$n = |i|$的一个问题实例，该算法可以在$O(T(n))$时间内给出问题的解，我们就说该算法在时间$O(T(n))$内解决该问题.

**Definition** 若一个具体问题是多项式时间内可解，则存在一个算法可以在$O(n^k)$时间内解决该问题. 

**Definition** 把多项式时间内可解的具体判定问题组成的集合称为==复杂类 P==（complexity class P）

**Definition** 抽象对象集合$S$的==编码==（encodings）是$S$从$S$到二进制串集合的一个映射$e$.

**Definition** 用$e(Q)$表示一个抽象问题到具体问题的映射，即实际上$e: I \to \{0,1 \}^*$，且某个抽象问题的实例$i \in I$，对应具体问题实例$e(i)$，它们两个的解是相同.  

**Definition** 给定一个二进制串上的函数$f: \{0,1\}^* \to \{0,1\}^*$，如果存在一个多项式时间的算法A，它对任意给定的输入$x \in \{0,1\}^*$，都能产生输出$f(x)$，则称该函数是一个==多项式时间可计算==的函数.  换句话说算法A是$f$的一个多项式时间内的表示. 

**Definition** 如果存在两个多项式时间可计算的函数$f_{12}$和$f_{21}$满足对任意$i \in I$，有$f_{12}(e_1(i)) = e_2(i)$和$f_{21}(e_2(i)) = e_1(i)$成立，我们则称$e_1$和$e_2$是==多项式相关==.  换句话就是$e_2(i)$可以由一个多项式算法根据$e_1(i)$求出.



**Lemma** 设$Q$是定义在一个实例集$I$上的一个抽象判定问题，$e_1$和$e_2$是$I$上多项式相关的编码，则$e_1(Q) \in P$当且仅当$e_2(Q) \in P$. 



**为什么要引入编码？**

我们希望通过编码的方式把多项式时间可解性从具体问题扩展到抽象问题，但同时希望这一定义与任何特定的编码无关，即求解一个问题的效率不应依赖于问题的编码. 遗憾是的这种依赖性是比较严重的，但是如果不指定编码就无法真正的谈论对一个抽象问题的求解.   

退而求其次，我们可以归纳出来某些编码对问题的复杂度作用是等价的，因此只要我们确定一种标准对问题复杂度没有影响的编码，我们可以很快的通过它推导出其他的编码方式（数学对象），对问题的复杂度均是没有影响的。 我们尽可能的在他们的作用下再去谈论复杂性，同时这个他们也给了我们很多选择. 









**如何证明一个问题是NPC**？

